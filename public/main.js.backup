// main.js - 통합된 멀티플레이어 게임 엔진
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.124/build/three.module.js';
import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.124/examples/jsm/controls/OrbitControls.js';
import { player } from './player.js';
import { object } from './object.js';
import { Item } from './item.js';
import { math } from './math.js';
import { ui } from './ui.js';
import { hp } from './hp.js';
import { WEAPON_DATA, WeaponFactory, WeaponManager, ATTACK_TYPE_MELEE, ATTACK_TYPE_RANGED } from './weapon_system.js';
import { SoundManager } from './soundManager.js';
import { initMuzzleFlashPool, muzzleFlashPool } from './effects.js';
import { NetworkSyncSystem } from './networkSync.js';

const socket = io();

class GameStage3 {
    constructor(socket, roomId, players, map) {
        this.socket = socket;
        this.roomId = roomId;
        this.playerData = players;
        this.mapName = map;

        // UI 초기화
        this.playerHpUI = playerHpUI;
        this.npcHpUI = npcHpUI;
        this.npcUI = npcUI;
        this.playerStatUI = playerStatUI;

        // 게임 상태 초기화
        this.healthLogTimer_ = 0;
        this.npcs_ = [];
        this.weapons_ = [];
        this.weaponSpawnTimer_ = 0;
        this.weaponSpawnInterval_ = 10;
        this.MAX_WEAPONS_ON_MAP = 10;
        this.soundManager = soundManager;
        this.players = new Map();
        this.localPlayer = null;

        // 네트워크 동기화 시스템 초기화
        this.networkSync = networkSync;

        // 게임 초기화 및 렌더링 루프 시작
        this.Initialize();
        this.RAF();
    }
    Initialize() {
        // WebGL 렌더러 초기화
        this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        this.renderer.setPixelRatio(window.devicePixelRatio);
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        this.renderer.outputEncoding = THREE.sRGBEncoding;
        this.renderer.gammaFactor = 2.2;
        document.getElementById('container').appendChild(this.renderer.domElement);

        // 카메라 초기화
        const fov = 60;
        const aspect = window.innerWidth / window.innerHeight;
        const near = 1.0;
        const far = 2000.0;
        this.camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
        this.camera.position.set(-8, 6, 12);
        this.camera.lookAt(0, 2, 0);

        // 씬 초기화
        this.scene = new THREE.Scene();

        // 총구 화염 이펙트 풀 초기화
        initMuzzleFlashPool(this.scene, 20);

        // 환경 설정
        this.SetupLighting();
        this.SetupSkyAndFog();
        this.CreateGround();

        // 무기 생성
        for (let i = 0; i < this.MAX_WEAPONS_ON_MAP; i++) {
            this.spawnSingleWeapon();
        }

        // 플레이어 생성
        this.SetupNetworking();
        this.CreatePlayers();
        this.CreateNPCs();
        this.CreateCoordinateDisplays();

        // 이벤트 리스너 설정
        window.addEventListener('resize', () => this.OnWindowResize(), false);
        window.addEventListener('mousemove', (e) => this.OnMouseMove(e), false);

        // 네트워크 동기화 시스템 초기화
        if (this.networkSync) {
            this.networkSync.initialize(this.scene, this.localPlayer);
        }

        // 게임 정보 표시
        document.getElementById('info').style.display = 'block';
        document.getElementById('controls').style.display = 'block';
    }

    SetupNetworking() {
        if (!this.socket) return;

        // 플레이어 연결 이벤트 리스너
        this.socket.on('playerJoined', (playerData) => {
            console.log(`플레이어 입장: ${playerData.id}`);
            this.AddRemotePlayer(playerData);
        });

        // 플레이어 퇴장 이벤트 리스너
        this.socket.on('playerLeft', (playerId) => {
            console.log(`플레이어 퇴장: ${playerId}`);
            this.RemovePlayer(playerId);
        });
    }

    AddRemotePlayer(playerData) {
        if (this.players.has(playerData.id)) return;

        // 원격 플레이어 생성
        const remotePlayer = new player.Player({
            scene: this.scene,
            isRemote: true,
            character: playerData.character,
            hpUI: new hp.HPUI(),
            soundManager: this.soundManager,
            camera: this.camera
        });

        // 플레이어 맵에 추가
        this.players.set(playerData.id, remotePlayer);

        // 네트워크 동기화 시스템에 플레이어 추가
        if (this.networkSync) {
            this.networkSync.addPlayer(playerData.id, remotePlayer);
        }
    }

    RemovePlayer(playerId) {
        const player = this.players.get(playerId);
        if (!player) return;

        // 씬에서 플레이어 제거
        if (player.mesh_ && player.mesh_.parent) {
            player.mesh_.parent.remove(player.mesh_);
        }

        // 플레이어 맵에서 제거
        this.players.delete(playerId);

        // 네트워크 동기화 시스템에서 플레이어 제거
        if (this.networkSync) {
            this.networkSync.removePlayer(playerId);
        }
    }

    CreatePlayers() {
        // 로컬 플레이어 생성
        const localPlayerData = this.playerData.find(p => p.id === this.socket.id);
        if (localPlayerData) {
            this.localPlayer = new player.Player({
                scene: this.scene,
                hpUI: this.playerHpUI,
                weapons: this.weapons_,
                npcs: this.npcs_,
                soundManager: this.soundManager,
                camera: this.camera,
                socket: this.socket,
                roomId: this.roomId,
                character: localPlayerData.character
            });

            this.playerHpUI.setTarget(this.localPlayer);
            this.playerStatUI.show(localPlayerData.nickname || 'Player');

            // 플레이어 맵에 추가
            this.players.set(this.socket.id, this.localPlayer);

            // 전역 참조 설정
            window.playerInstance = this.localPlayer;
            localPlayerId = this.socket.id;
        }

        // 원격 플레이어 생성
        this.playerData.forEach(playerData => {
            if (playerData.id !== this.socket.id) {
                this.AddRemotePlayer(playerData);
            }
        });

        // 카메라 오프셋 및 회전
        this.cameraTargetOffset = new THREE.Vector3(0, 15, 10);
        this.rotationAngle = 4.715;
    }

    CreateNPCs() {
        // NPC 생성
        const npcPos = new THREE.Vector3(0, 0, -4);
        const newNpc = new object.NPC(this.scene, npcPos, 'Viking Warrior', this.soundManager);
        this.npcs_.push(newNpc);
        this.npc_ = newNpc; // 기존 this.npc_ 참조 유지 (단일 NPC의 경우)
        this.npcHpUI.setTarget(this.npc_);

        // 전역 참조 설정
        window.npcList = this.npcs_;

        // NPC 얼굴 이미지 추출
        const checkAndRenderNPCFace = () => {
            if (this.npc_ && this.npc_.model_) {
                this.npcHpUI.renderCharacterFaceToProfile(this.npc_.model_, this.scene, this.renderer);
            } else {
                setTimeout(checkAndRenderNPCFace, 100);
            }
        };
        checkAndRenderNPCFace();
    }

    SetupLighting() {
        // 방향성 조명
        const directionalLight = new THREE.DirectionalLight(0xFFFFFF, 1.2);
        directionalLight.position.set(60, 100, 10);
        directionalLight.target.position.set(0, 0, 0);
        directionalLight.castShadow = true;
        directionalLight.shadow.bias = -0.001;
        directionalLight.shadow.mapSize.width = 1024;
        directionalLight.shadow.mapSize.height = 1024;
        directionalLight.shadow.camera.near = 1.0;
        directionalLight.shadow.camera.far = 200.0;
        directionalLight.shadow.camera.left = -50;
        directionalLight.shadow.camera.right = 50;
        directionalLight.shadow.camera.top = 50;
        directionalLight.shadow.camera.bottom = -50;
        this.scene.add(directionalLight);
        this.scene.add(directionalLight.target);

        // 반구 조명
        const hemisphereLight = new THREE.HemisphereLight(0x87CEEB, 0xF6F47F, 0.6);
        this.scene.add(hemisphereLight);
    }

    SetupSkyAndFog() {
        // 하늘 셰이더
        const skyUniforms = {
            topColor: { value: new THREE.Color(0x0077FF) },
            bottomColor: { value: new THREE.Color(0x89b2eb) },
            offset: { value: 33 },
            exponent: { value: 0.6 }
        };
        const skyGeometry = new THREE.SphereGeometry(1000, 32, 15);
        const skyMaterial = new THREE.ShaderMaterial({
            uniforms: skyUniforms,
            vertexShader: `
        varying vec3 vWorldPosition;
        void main() {
          vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
          vWorldPosition = worldPosition.xyz;
          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        }`,
            fragmentShader: `
        uniform vec3 topColor;
        uniform vec3 bottomColor;
        uniform float offset;
        uniform float exponent;
        varying vec3 vWorldPosition;
        void main() {
          float h = normalize( vWorldPosition + offset ).y;
          gl_FragColor = vec4( mix( bottomColor, topColor, max( pow( max( h, 0.0), exponent ), 0.0 ) ), 1.0 );
        }`,
            side: THREE.BackSide,
        });
        const skyMesh = new THREE.Mesh(skyGeometry, skyMaterial);
        this.scene.add(skyMesh);

        // 안개
        this.scene.fog = new THREE.FogExp2(0x89b2eb, 0.002);
    }

    CreateGround() {
        // 맵 선택에 따른 텍스처 로드
        const textureLoader = new THREE.TextureLoader();
        let mapTexture;

        if (this.mapName === 'map2') {
            mapTexture = textureLoader.load('./resources/Map2.png');
        } else {
            mapTexture = textureLoader.load('./resources/Map1.png');
        }

        mapTexture.wrapS = THREE.RepeatWrapping;
        mapTexture.wrapT = THREE.RepeatWrapping;
        mapTexture.repeat.set(2, 2);

        // 바닥 메쉬
        const groundGeometry = new THREE.PlaneGeometry(80, 80, 10, 10);
        const groundMaterial = new THREE.MeshLambertMaterial({
            map: mapTexture,
        });
        this.ground = new THREE.Mesh(groundGeometry, groundMaterial);
        this.ground.rotation.x = -Math.PI / 2;
        this.ground.position.y = 0;
        this.ground.receiveShadow = true;
        this.scene.add(this.ground);
    }

    CreateCoordinateDisplays() {
        const style = {
            position: 'absolute',
            background: 'rgba(0, 0, 0, 0.6)',
            color: '#fff',
            padding: '5px 10px',
            borderRadius: '5px',
            fontFamily: 'monospace',
            fontSize: '12px',
            zIndex: '1000',
            pointerEvents: 'none',
            userSelect: 'none',
            transform: 'translate(-50%, -50%)'
        };

        this.playerCoordDisplay = document.createElement('div');
        Object.assign(this.playerCoordDisplay.style, style);
        document.body.appendChild(this.playerCoordDisplay);
    }

    spawnSingleWeapon() {
        if (this.weapons_.length >= this.MAX_WEAPONS_ON_MAP) {
            return;
        }

        const weaponNames = Object.keys(WEAPON_DATA);
        const randomIndex = math.rand_int(0, weaponNames.length - 1);
        const weaponName = weaponNames[randomIndex];

        // Potion은 특정 위치에만 생성되도록 예외 처리
        let pos;
        if (weaponName === 'Potion1_Filled.fbx') {
            pos = new THREE.Vector3(0, 1, 4);
        } else {
            pos = new THREE.Vector3(math.rand_int(-20, 20), 1, math.rand_int(-20, 20));
        }

        const weaponData = WEAPON_DATA[weaponName];
        if (weaponData) {
            const weapon = new Item(this.scene, weaponName, pos, weaponData.type, weaponData.radius, weaponData.angle, weaponData.damage, weaponData.attackSpeedMultiplier, weaponData.attackType, weaponData.specialEffect, weaponData.statEffect);
            this.weapons_.push(weapon);

            // 무기 생성 이벤트 동기화
            if (this.socket && this.networkSync) {
                this.networkSync.syncItemPickup({
                    itemId: this.weapons_.length - 1,
                    itemName: weaponName,
                    position: [pos.x, pos.y, pos.z],
                    type: 'spawn'
                });
            }
        }
    }

    OnMouseMove(event) {
        if (event.buttons === 1) {
            const deltaX = event.movementX || 0;
            this.rotationAngle -= deltaX * 0.005;
        }
    }

    UpdateCamera() {
        if (!this.localPlayer || !this.localPlayer.mesh_) return;

        const target = this.localPlayer.mesh_.position.clone();
        const offset = this.cameraTargetOffset.clone();
        offset.applyAxisAngle(new THREE.Vector3(0, 1, 0), this.rotationAngle);
        const cameraPos = target.clone().add(offset);
        this.camera.position.copy(cameraPos);

        // 머리 위를 바라보게
        const headOffset = new THREE.Vector3(0, 2, 0);
        const headPosition = target.clone().add(headOffset);
        this.camera.lookAt(headPosition);
    }

    OnWindowResize() {
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
    }

    RAF(time) {
        requestAnimationFrame((t) => this.RAF(t));

        if (!this.prevTime) this.prevTime = time || performance.now();
        const delta = ((time || performance.now()) - this.prevTime) * 0.001;
        this.prevTime = time || performance.now();

        // 무기 소환 타이머 업데이트 및 소환
        this.weaponSpawnTimer_ += delta;
        if (this.weaponSpawnTimer_ >= this.weaponSpawnInterval_) {
            this.spawnSingleWeapon();
            this.weaponSpawnTimer_ = 0;
        }

        // 로컬 플레이어 업데이트
        if (this.localPlayer) {
            this.localPlayer.Update(delta, this.rotationAngle);
            this.UpdateCamera();
            this.playerHpUI.updateHP(this.localPlayer.hp_);

            if (this.localPlayer.mesh_) {
                const stats = {
                    health: `${this.localPlayer.hp_} / ${this.localPlayer.maxHp_}`,
                    speed: this.localPlayer.speed_,
                    strength: this.localPlayer.strength_,
                    agility: this.localPlayer.agility_,
                    stamina: this.localPlayer.stamina_
                };

                // 마지막 투사체 정보 추가
                if (this.localPlayer.lastMeleeProjectile && !this.localPlayer.lastMeleeProjectile.isDestroyed) {
                    stats.projectilePosition = this.localPlayer.lastMeleeProjectile.position;
                    stats.projectileRadius = this.localPlayer.lastMeleeProjectile.radius;
                }

                this.playerStatUI.updateStats(stats);
            }
        }

        // 원격 플레이어 업데이트
        this.players.forEach((player, id) => {
            if (id !== localPlayerId && player.mixer_) {
                player.mixer_.update(delta);
            }
        });

        // NPC 업데이트
        if (this.npc_ && this.npc_.model_) {
            this.npc_.Update(delta);
            this.npcHpUI.updateHP(this.npc_.health_);

            // NPC UI 위치 및 가시성 업데이트
            const npcWorldPosition = new THREE.Vector3();
            if (this.npc_.headBone) {
                this.npc_.headBone.getWorldPosition(npcWorldPosition);
            } else {
                npcWorldPosition.copy(this.npc_.model_.position);
            }
            npcWorldPosition.y += 2.0; // 머리 위로 오프셋

            const screenPosition = npcWorldPosition.clone().project(this.camera);

            const width = window.innerWidth, height = window.innerHeight;
            const x = (screenPosition.x * width / 2) + width / 2;
            const y = -(screenPosition.y * height / 2) + height / 2;

            // NPC가 화면에 있는지 확인
            const isBehind = screenPosition.z > 1;
            const isOnScreen = x > 0 && x < width && y > 0 && y < height && !isBehind;

            if (isOnScreen) {
                this.npcUI.show(this.npc_.name, this.npc_.health_);
                this.npcUI.updatePosition(x + 50, y); // NPC 오른쪽에 위치
            } else {
                this.npcUI.hide();
            }
        }

        // 좌표 디스플레이 업데이트
        this.UpdateCoordinateDisplays();

        // 렌더링
        this.renderer.render(this.scene, this.camera);

        // 투사체 및 이펙트 업데이트
        if (this.localPlayer && this.localPlayer.attackSystem) {
            this.localPlayer.attackSystem.update(delta, this.npcs_);
        }

        if (muzzleFlashPool) {
            muzzleFlashPool.update(delta);
        }

        // 충돌 및 전투 업데이트
        this.UpdateCombat(delta);

        // 네트워크 동기화 시스템 업데이트
        if (this.networkSync) {
            this.networkSync.update(delta);
        }
    }

    UpdateCombat(delta) {
        if (!this.localPlayer || !this.localPlayer.mesh_ || this.npcs_.length === 0) {
            return;
        }

        const playerPosition = this.localPlayer.mesh_.position;
        const playerRadius = this.localPlayer.hitboxRadius_;

        this.npcs_.forEach(npc => {
            if (!npc.model_ || npc.isDead_) return;

            const npcPosition = npc.model_.position;
            const npcRadius = npc.hitboxRadius_;

            const distanceVector = new THREE.Vector3().subVectors(playerPosition, npcPosition);
            distanceVector.y = 0; // Y축은 무시하고 XZ 평면에서만 충돌 처리
            const distance = distanceVector.length();

            const minDistance = playerRadius + npcRadius;

            if (distance < minDistance) {
                // 충돌 발생
                const overlap = minDistance - distance;
                const direction = distanceVector.normalize();

                // 플레이어와 NPC를 서로 밀어냄
                const pushAmount = direction.multiplyScalar(overlap / 2);

                this.localPlayer.mesh_.position.add(pushAmount);
                this.localPlayer.position_.copy(this.localPlayer.mesh_.position);

                npc.model_.position.sub(pushAmount);
            }
        });
    }

    UpdateCoordinateDisplays() {
        if (this.localPlayer && this.localPlayer.mesh_) {
            this.UpdateCoordDisplay(this.playerCoordDisplay, this.localPlayer.mesh_, this.localPlayer.headBone, 2.0);
        }
    }

    UpdateCoordDisplay(element, model, headBone, heightOffset) {
        const pos = new THREE.Vector3();
        if (headBone) {
            headBone.getWorldPosition(pos);
        } else {
            pos.copy(model.position);
        }
        pos.y += heightOffset;

        pos.project(this.camera);

        const width = window.innerWidth, height = window.innerHeight;
        const widthHalf = width / 2, heightHalf = height / 2;

        pos.x = (pos.x * widthHalf) + widthHalf;
        pos.y = - (pos.y * heightHalf) + heightHalf;

        element.style.top = `${pos.y}px`;
        element.style.left = `${pos.x}px`;

        const worldPos = model.position;
        element.textContent = `X: ${worldPos.x.toFixed(1)}, Y: ${worldPos.y.toFixed(1)}, Z: ${worldPos.z.toFixed(1)}`;
    }
}

// 전역 변수
let gameUI = null;
let playerHpUI = null;
let npcHpUI = null;
let npcUI = null;
let playerStatUI = null;
let soundManager = null;
let networkSync = null;
let localPlayerId = null;

// 메뉴 UI 요소
const menu = document.getElementById('menu');
const controls = document.getElementById('controls');
const createRoomButton = document.getElementById('createRoomButton');
const joinRoomMainButton = document.getElementById('joinRoomMainButton');
const joinRoomPopup = document.getElementById('joinRoomPopup');
const publicRoomList = document.getElementById('publicRoomList');
const privateRoomCodeInput = document.getElementById('privateRoomCodeInput');
const popupJoinButton = document.getElementById('popupJoinButton');
const popupCloseButton = document.getElementById('popupCloseButton');
const waitingRoom = document.getElementById('waitingRoom');
const waitingRoomIdDisplay = document.getElementById('waitingRoomIdDisplay');
const playerList = document.getElementById('playerList');
const readyButton = document.getElementById('readyButton');
const startGameButton = document.getElementById('startGameButton');

// 방 생성 팝업 요소
const createRoomSettingsPopup = document.getElementById('createRoomSettingsPopup');
const characterNicknamePopup = document.getElementById('characterNicknamePopup');
const mapSelectionContainer = document.getElementById('mapSelectionContainer');
const mapThumbnails = document.querySelectorAll('.map-thumbnail');
const maxPlayersCreate = document.getElementById('maxPlayersCreate');
const roomVisibility = document.getElementById('roomVisibility');
const createRoomConfirmButton = document.getElementById('createRoomConfirmButton');
const createRoomCancelButton = document.getElementById('createRoomCancelButton');
const roomNameCreate = document.getElementById('roomNameCreate');
const playerSlotsContainer = document.getElementById('playerSlotsContainer');
const waitingRoomTitle = document.getElementById('waitingRoomTitle');
const currentMapImage = document.getElementById('currentMapImage');
const mapPlaceholderText = document.getElementById('mapPlaceholderText');

// 메뉴 UI 전역 변수
let roomSettings = {}; // 방 생성 설정 저장
let joinRoomId = null; // 참가할 방 ID 저장
let isRoomCreator = false; // 방장 여부
let selectedPublicRoomId = null; // 선택된 공개방 ID

// === 디버그 히트박스 전역 플래그 ===
window.DEBUG_MODE_HITBOXES = false;
window.addEventListener('keydown', (e) => {
    if (e.key === 'q') {
        window.DEBUG_MODE_HITBOXES = !window.DEBUG_MODE_HITBOXES;
        if (window.playerInstance && typeof window.playerInstance.setDebugHitboxVisible === 'function') {
            window.playerInstance.setDebugHitboxVisible(window.DEBUG_MODE_HITBOXES);
        }
        if (window.npcList && Array.isArray(window.npcList)) {
            window.npcList.forEach(npc => {
                if (npc && typeof npc.setDebugHitboxVisible === 'function') {
                    npc.setDebugHitboxVisible(window.DEBUG_MODE_HITBOXES);
                }
            });
        }
    }
});

// 게임 초기화 함수
function initGame(socket, roomId, players, map) {
    // UI 초기화
    gameUI = new ui.GameUI();
    playerHpUI = new hp.HPUI();
    playerHpUI.setGameUI(gameUI);
    npcHpUI = new hp.HPUI(true);
    npcUI = new ui.NPCUI();
    playerStatUI = new ui.PlayerStatUI();

    // 사운드 매니저 초기화
    soundManager = new SoundManager();
    loadGameSounds();

    // 네트워크 동기화 시스템 초기화
    networkSync = new NetworkSyncSystem(socket, roomId);

    // 게임 인스턴스 생성
    return new GameStage3(socket, roomId, players, map);
}

// 게임 사운드 로드 함수
function loadGameSounds() {
    soundManager.loadSound('attack_swing', './resources/audio/attack_swing.mp3');
    soundManager.loadSound('hit_impact', './resources/audio/hit_impact.mp3');
    soundManager.loadSound('jump_sound', './resources/audio/jump_sound.mp3');
}

// 플레이어 목록 업데이트 함수
function updatePlayers(players, maxPlayers) {
  playerSlotsContainer.innerHTML = '';
  const totalSlots = 8; // 항상 8개의 슬롯 표시

  for (let i = 0; i < totalSlots; i++) {
    const playerSlot = document.createElement('div');
    playerSlot.classList.add('player-slot');

    const playerInfo = players[i];
    if (i < maxPlayers) { // 열린 슬롯
      if (playerInfo) {
        playerSlot.style.border = '2px solid #4CAF50';
        playerSlot.style.backgroundColor = 'rgba(76, 175, 80, 0.3)';
        playerSlot.innerHTML = `
          <img src="./resources/character/${playerInfo.character}.png" alt="${playerInfo.nickname}" style="width: 80px; height: 80px; border-radius: 50%; object-fit: cover; margin-bottom: 5px;">
          <p style="margin: 0;">${playerInfo.nickname}</p>
          <p style="margin: 0; font-size: 12px; color: #eee;">${playerInfo.ready ? '(준비)' : '(대기)'}</p>
        `;
        if (isRoomCreator) {
          const closeBtn = document.createElement('div');
          closeBtn.classList.add('close-slot-btn');
          closeBtn.textContent = 'X';
          closeBtn.addEventListener('click', (e) => {
            e.stopPropagation(); // 클릭이 슬롯 자체로 전파되는 것을 방지
            socket.emit('closePlayerSlot', i); // 슬롯 인덱스 전송
          });
          playerSlot.appendChild(closeBtn);
        }
      } else {
        playerSlot.style.border = '2px dashed #aaa';
        playerSlot.style.backgroundColor = 'rgba(255, 255, 255, 0.1)';
        playerSlot.innerHTML = `<p>슬롯 ${i + 1}</p><p>(비어있음)</p>`;
        if (isRoomCreator) {
          const closeBtn = document.createElement('div');
          closeBtn.classList.add('close-slot-btn');
          closeBtn.textContent = 'X';
          closeBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            socket.emit('closePlayerSlot', i);
          });
          playerSlot.appendChild(closeBtn);
        }
      }
    } else { // 닫힌 슬롯
      playerSlot.classList.add('closed');
      playerSlot.innerHTML = `<p>슬롯 ${i + 1}</p>`;
      if (isRoomCreator) {
        playerSlot.addEventListener('click', () => {
          socket.emit('increaseMaxPlayers');
        });
      }
    }
    playerSlotsContainer.appendChild(playerSlot);
  }
}

// 방 생성 버튼 클릭 이벤트
createRoomButton.addEventListener('click', () => {
  createRoomSettingsPopup.style.display = 'flex'; // 방 생성 설정 팝업 표시
});

// 방 생성 확인 버튼 클릭 이벤트
createRoomConfirmButton.addEventListener('click', () => {
  const selectedMapElement = document.querySelector('.map-thumbnail.selected');
  const selectedMap = selectedMapElement ? selectedMapElement.dataset.map : 'map1'; // 선택된 맵이 없으면 기본값 map1
  const maxPlayers = parseInt(maxPlayersCreate.value, 10);
  const visibility = roomVisibility.value;
  const selectedRoundTimeButton = document.querySelector('#roundTimeOptions .round-time-btn.selected');
  const roundDuration = selectedRoundTimeButton ? parseInt(selectedRoundTimeButton.dataset.value, 10) : 180; // 기본값 180초
  const roomName = roomNameCreate.value.trim();

  if (!roomName) {
    alert('방 이름을 입력해주세요.');
    return;
  }

  if (isNaN(maxPlayers) || maxPlayers < 2 || maxPlayers > 8) {
    alert('최대 인원은 2에서 8 사이의 숫자로 설정해주세요.');
    return;
  }
  if (isNaN(roundDuration) || roundDuration < 60 || roundDuration > 600) {
    alert('라운드 시간은 60초에서 600초 사이로 설정해주세요.');
    return;
  }

  roomSettings = { map: selectedMap, maxPlayers: maxPlayers, visibility: visibility, roundTime: roundDuration, roomName: roomName };

  createRoomSettingsPopup.style.display = 'none'; // 방 생성 설정 팝업 숨기기
  characterNicknamePopup.style.display = 'flex'; // 캐릭터 및 닉네임 선택 팝업 표시
  initializeCharacterSelection(); // 캐릭터 선택 UI 초기화
});

// 방 생성 취소 버튼 클릭 이벤트
createRoomCancelButton.addEventListener('click', () => {
  createRoomSettingsPopup.style.display = 'none'; // 팝업 숨기기
});

// 맵 선택 로직
mapThumbnails.forEach(thumbnail => {
  thumbnail.addEventListener('click', () => {
    mapThumbnails.forEach(t => t.classList.remove('selected'));
    thumbnail.classList.add('selected');
  });
});

// 방 참가 버튼 클릭 이벤트
joinRoomMainButton.addEventListener('click', () => {
  joinRoomPopup.style.display = 'flex'; // 팝업 표시
  socket.emit('getPublicRooms'); // 공개방 목록 요청
});

// 공개방 목록 수신 이벤트
socket.on('publicRoomsList', (rooms) => {
  publicRoomList.innerHTML = '';
  if (rooms.length === 0) {
    publicRoomList.innerHTML = '<li style="padding: 10px; border-bottom: 1px solid #eee; text-align: left;">공개방이 없습니다.</li>';
    return;
  }
  rooms.forEach(room => {
    const li = document.createElement('li');
    li.style.cssText = 'padding: 10px; border-bottom: 1px solid #eee; text-align: left; cursor: pointer; background-color: #f9f9f9;';
    const statusText = room.status === 'playing' ? '게임중' : '대기중';
    const statusColor = room.status === 'playing' ? 'red' : 'green';
    li.innerHTML = `${room.name} (ID: ${room.id.substring(0, 4)}, 인원: ${room.players}/${room.maxPlayers}, 맵: ${room.map}) <span style="color: ${statusColor}; float: right;">${statusText}</span>`;
    li.dataset.roomId = room.id;

    if (room.status === 'playing') {
      li.style.cursor = 'not-allowed';
      li.style.color = '#aaa';
    } else {
      li.addEventListener('click', () => {
        if (selectedPublicRoomId === room.id) {
          selectedPublicRoomId = null;
          li.style.backgroundColor = '#f9f9f9';
        } else {
          const prevSelected = document.querySelector('#publicRoomList li[style*="background-color: #e0e0e0"]');
          if (prevSelected) {
            prevSelected.style.backgroundColor = '#f9f9f9';
          }
          selectedPublicRoomId = room.id;
          li.style.backgroundColor = '#e0e0e0';
        }
      });
    }
    publicRoomList.appendChild(li);
  });
});

// 방 참가 버튼 클릭 이벤트
popupJoinButton.addEventListener('click', () => {
  let roomIdToJoin = null;
  if (selectedPublicRoomId) {
    roomIdToJoin = selectedPublicRoomId;
  } else {
    roomIdToJoin = privateRoomCodeInput.value.trim();
  }

  if (roomIdToJoin) {
    joinRoomId = roomIdToJoin; // 나중에 사용하기 위해 방 ID 저장
    joinRoomPopup.style.display = 'none'; // 방 참가 팝업 숨기기
    characterNicknamePopup.style.display = 'flex'; // 캐릭터 및 닉네임 선택 팝업 표시
    initializeCharacterSelection(); // 캐릭터 선택 UI 초기화
    selectedPublicRoomId = null; // 선택된 방 초기화
  } else {
    alert('공개방을 선택하거나 비밀방 코드를 입력해주세요.');
  }
});

// 팝업 닫기 버튼 클릭 이벤트
popupCloseButton.addEventListener('click', () => {
  joinRoomPopup.style.display = 'none'; // 팝업 숨기기
});

// 준비 버튼 클릭 이벤트
readyButton.addEventListener('click', () => {
  socket.emit('ready');
});

// 게임 시작 버튼 클릭 이벤트
startGameButton.addEventListener('click', () => {
  if (!startGameButton.disabled) {
    socket.emit('startGameRequest');
  }
});

// 방 생성 완료 이벤트
socket.on('roomCreated', (roomInfo) => {
  waitingRoomIdDisplay.textContent = `ID: ${roomInfo.id}`;
  waitingRoomTitle.textContent = `${roomInfo.name} (ID: ${roomInfo.id})`;
  waitingRoomIdDisplay.style.display = 'none';
  const capitalizedMapName = roomInfo.map.charAt(0).toUpperCase() + roomInfo.map.slice(1);
  currentMapImage.src = `./resources/${capitalizedMapName}.png`;
  currentMapImage.style.display = 'block';
  mapPlaceholderText.style.display = 'none';
  isRoomCreator = true; // 방장으로 설정
  startGameButton.style.display = 'block'; // 게임 시작 버튼 표시
});

// 방 참가 완료 이벤트
socket.on('roomJoined', (roomInfo) => {
  waitingRoomIdDisplay.textContent = `ID: ${roomInfo.id}`;
  waitingRoomTitle.textContent = `${roomInfo.name} (ID: ${roomInfo.id})`;
  waitingRoomIdDisplay.style.display = 'none';
  const capitalizedMapName = roomInfo.map.charAt(0).toUpperCase() + roomInfo.map.slice(1);
  currentMapImage.src = `./resources/${capitalizedMapName}.png`;
  currentMapImage.style.display = 'block';
  mapPlaceholderText.style.display = 'none';
});

// 플레이어 목록 업데이트 이벤트
socket.on('updatePlayers', (players, maxPlayers) => {
  updatePlayers(players, maxPlayers);
  if (isRoomCreator) {
    const allReady = players.every(p => p.ready);
    startGameButton.disabled = !allReady;
  }
});

// 게임 시작 이벤트
socket.on('startGame', (data) => {
  // 메뉴 및 대기실 숨기기
  menu.style.display = 'none';
  waitingRoom.style.display = 'none';
  controls.style.display = 'block';

  // 게임 초기화
  const game = initGame(socket, data.roomId, data.players, data.map);
});

// 방 오류 이벤트
socket.on('roomError', (message) => {
  alert(`방 오류: ${message}`);
  menu.style.display = 'flex'; // 오류 발생 시 메뉴 다시 표시
  waitingRoom.style.display = 'none';
  joinRoomPopup.style.display = 'none';
});

// 캐릭터 선택 이벤트 리스너
document.addEventListener('characterSelected', (event) => {
  const { character, nickname } = event.detail;

  if (!nickname) {
    alert('닉네임을 입력해주세요.');
    return;
  }

  menu.style.display = 'none'; // 메인 메뉴 숨기기
  waitingRoom.style.display = 'flex'; // 대기실 표시

  // 방 생성 또는 참가 로직 분기
  if (roomSettings.map) { // 방 생성 흐름
    socket.emit('createRoom', { ...roomSettings, nickname: nickname, character: character });
    roomSettings = {}; // 사용 후 방 설정 초기화
  } else if (joinRoomId) { // 방 참가 흐름
    socket.emit('joinRoom', joinRoomId, nickname, character);
    waitingRoomIdDisplay.textContent = `방 ID: ${joinRoomId}`;
    joinRoomId = null; // 사용 후 방 ID 초기화
  } else {
    alert('방 생성 또는 참가 정보가 없습니다.');
    // 에러 처리 또는 초기 화면으로 돌아가는 로직
    menu.style.display = 'flex';
    waitingRoom.style.display = 'none';
    return;
  }
});

// 라운드 시간 버튼 이벤트 리스너
const roundTimeButtons = document.querySelectorAll('.round-time-btn');
roundTimeButtons.forEach(button => {
  button.addEventListener('click', () => {
    roundTimeButtons.forEach(btn => btn.classList.remove('selected'));
    button.classList.add('selected');
  });
});

// 캐릭터 선택 관련 스크립트
const characters = document.querySelectorAll('.character');
const previewCharacterName = document.getElementById('previewCharacterName');
const nicknameInput = document.getElementById('nicknameInput');
const enterBtn = document.getElementById('enterBtn');
let selectedChar = null;

const canvas = document.getElementById('previewCanvas');
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, 320 / 420, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ canvas, alpha: true });
renderer.setSize(320, 420);
renderer.setPixelRatio(window.devicePixelRatio);

const ambientLight = new THREE.AmbientLight(0xffffff, 0.9);
scene.add(ambientLight);
const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
directionalLight.position.set(0, 1, 1).normalize();
scene.add(directionalLight);
const frontLight = new THREE.DirectionalLight(0xffffff, 0.8);
frontLight.position.set(0, 1, 2);
scene.add(frontLight);

camera.position.set(0, 1, 2.5);
camera.lookAt(0, 1, 0);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enablePan = false;
controls.enableZoom = false;
controls.enableRotate = true;
controls.enableDamping = true;
controls.dampingFactor = 0.05;
controls.rotateSpeed = 0.5;
controls.minPolarAngle = Math.PI / 2;
controls.maxPolarAngle = Math.PI / 2;

const loader = new THREE.GLTFLoader();
let currentModel = null;
let mixer = null;

function animate() {
  requestAnimationFrame(animate);
  if (mixer) mixer.update(0.016);
  controls.update();
  renderer.render(scene, camera);
}
animate();

function loadModel(gltfPath) {
  if (currentModel) {
    currentModel.traverse((object) => {
      if (object.isMesh) {
        if (object.geometry) {
          object.geometry.dispose();
        }
        if (object.material) {
          if (Array.isArray(object.material)) {
            object.material.forEach(material => material.dispose());
          } else {
            object.material.dispose();
          }
        }
      }
    });
    scene.remove(currentModel);
    currentModel = null;
  }
  if (mixer) {
    mixer.stopAllAction();
    mixer = null;
  }

  loader.load(
    gltfPath,
    (gltf) => {
      currentModel = gltf.scene;
      scene.add(currentModel);

      const box = new THREE.Box3().setFromObject(currentModel);
      const size = box.getSize(new THREE.Vector3()).length();
      const center = box.getCenter(new THREE.Vector3());
      currentModel.position.sub(center);
      currentModel.scale.set(3.0 / size, 3.0 / size, 3.0 / size);
      currentModel.position.y = -1.25;

      if (gltf.animations && gltf.animations.length) {
        mixer = new THREE.AnimationMixer(currentModel);
        const victoryAnim = gltf.animations.find(anim => anim.name.toLowerCase().includes('victory'));
        if (victoryAnim) {
          const action = mixer.clipAction(victoryAnim);
          action.play();
        }
      }
    },
    undefined,
    (error) => {
      console.error('glTF 로드 오류:', error);
    }
  );
}

let isClickEnabled = true;

characters.forEach(char => {
  char.addEventListener('click', () => {
    if (!isClickEnabled) return;

    isClickEnabled = false;
    setTimeout(() => {
      isClickEnabled = true;
    }, 1000);

    characters.forEach(c => c.classList.remove('selected'));
    char.classList.add('selected');
    const gltfPath = char.dataset.gltf;
    const name = char.querySelector('.character-name').textContent;
    previewCharacterName.textContent = name;
    loadModel(gltfPath);
    selectedChar = char;
  });
});

function initializeCharacterSelection() {
  const firstChar = document.querySelector('.character');
  if (firstChar) {
    characters.forEach(c => c.classList.remove('selected'));
    firstChar.classList.add('selected');
    previewCharacterName.textContent = firstChar.querySelector('.character-name').textContent;
    loadModel(firstChar.dataset.gltf);
    selectedChar = firstChar;
  }
}

window.initializeCharacterSelection = initializeCharacterSelection;

enterBtn.addEventListener('click', () => {
  if (!selectedChar) {
    alert('캐릭터를 선택해주세요.');
    return;
  }
  
  const gltfPath = selectedChar.dataset.gltf;
  const characterFileName = gltfPath.substring(gltfPath.lastIndexOf('/') + 1).replace('.gltf', '');
  const nickname = nicknameInput.value.trim() || 'Guest';
  
  document.getElementById('characterNicknamePopup').style.display = 'none';
  const event = new CustomEvent('characterSelected', {
    detail: { character: characterFileName, nickname: nickname }
  });
  document.dispatchEvent(event);
});

// 전역 변수 내보내기
export { socket, roomId, networkSync, gameUI, playerHpUI, npcHpUI, npcUI, playerStatUI, soundManager, players, localPlayerId };
